<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SoundMask AI</title>
    <style>
        body {
            font-family: 'Segoe UI', 'Courier New', monospace;
            background: #0a0a0a;
            color: #00ff88;
            margin: 0;
            padding: 20px;
        }
        .container { max-width: 500px; margin: 0 auto; }
        .header { text-align: center; margin-bottom: 20px; }
        .header h1 {
            font-size: 2.2rem;
            margin: 0;
            text-shadow: 0 0 20px #00ff88;
            background: linear-gradient(45deg, #00ff88, #00ccff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        .status, .result, .recommend {
            text-align: center;
            margin: 15px 0;
        }
        .status {
            padding: 12px;
            background: rgba(0, 255, 136, 0.08);
            border: 1px solid #00ff88;
            border-radius: 8px;
            font-size: 1.1rem;
        }
        .result {
            font-size: 1.3rem;
        }
        .recommend {
            font-size: 1.1rem;
            color: #ffaa00;
        }
        .controls { display: flex; justify-content: center; align-items: center; gap: 15px; margin: 20px 0; flex-wrap: wrap; }
        .btn {
            background: linear-gradient(45deg, #00ff88, #00ccff);
            color: #000;
            border: none;
            padding: 12px 24px;
            border-radius: 25px;
            cursor: pointer;
            font-weight: bold;
            font-size: 1rem;
            transition: all 0.3s;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 255, 136, 0.5);
        }
        .btn.active {
            background: linear-gradient(45deg, #ff4444, #ff6666);
            animation: pulse 2s infinite;
        }
        @keyframes pulse {
            0%, 100% { box-shadow: 0 0 5px rgba(255, 68, 68, 0.5); }
            50% { box-shadow: 0 0 25px rgba(255, 68, 68, 0.8); }
        }
        .timer-control {
            display: flex;
            align-items: center;
            gap: 10px;
            background: rgba(0, 255, 136, 0.1);
            border: 1px solid #00ff88;
            padding: 8px 15px;
            border-radius: 25px;
        }
        .timer-control label { font-size: 0.9rem; }
        .timer-control input {
            background: #333;
            color: #00ff88;
            border: 1px solid #00ff88;
            border-radius: 5px;
            width: 60px;
            text-align: center;
            font-family: 'Courier New', monospace;
        }
        .sound-controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
            gap: 10px;
            margin: 20px 0;
        }
        .sound-btn {
            background: rgba(0, 255, 136, 0.1);
            border: 1px solid #00ff88;
            color: #00ff88;
            padding: 15px 10px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.9rem;
            text-align: center;
            transition: all 0.3s;
        }
        .sound-btn:hover { background: rgba(0, 255, 136, 0.2); transform: scale(1.05); }
        .sound-btn.recommended {
            border-color: #ffaa00;
            background: rgba(255, 170, 0, 0.2);
            color: #ffaa00;
        }
        .sound-btn.playing {
            border-color: #ff4444;
            background: rgba(255, 68, 68, 0.2);
            color: #ff4444;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üéß SoundMask AI</h1>
            <p>Audio Classifier</p>
        </div>
        <div class="status" id="status">Initializing neural networks...</div>
        <div class="result" id="result"></div>
        <div class="recommend" id="recommend"></div>
        <div class="controls">
            <button class="btn" id="startBtn">Start Analysis</button>
            <button class="btn" id="stopAudioBtn">Stop All Audio</button>
            <div class="timer-control">
                <label for="timerInput">Loop Duration (s):</label>
                <input type="number" id="timerInput" min="0" value="3600" placeholder="‚àû">
            </div>
        </div>
        <div class="sound-controls">
            <div class="sound-btn" data-sound="white">‚ö™ White Noise</div>
            <div class="sound-btn" data-sound="rain">üåßÔ∏è Rain</div>
            <div class="sound-btn" data-sound="ocean">üåä Ocean</div>
            <div class="sound-btn" data-sound="forest">üå≤ Forest</div>
            <div class="sound-btn" data-sound="cafe">‚òï Cafe</div>
        </div>
    </div>

    <audio id="audio-whitenoise" src="whitenoise.wav" loop></audio>
    <audio id="audio-rain" src="rain.wav" loop></audio>
    <audio id="audio-ocean" src="ocean.wav" loop></audio>
    <audio id="audio-forest" src="forest.wav" loop></audio>
    <audio id="audio-cafe" src="cafe.wav" loop></audio>

    <script>
        class SoundMaskAI {
            constructor() {
                this.isRecording = false;
                this.audioContext = null;
                this.analyser = null;
                this.audioBuffer = null;
                this.nn = {};
                this.predictions = [0.25, 0.25, 0.25, 0.25];
                this.recommendations = [];
                this.activeTimer = null;
                this.init();
            }

            async init() {
                this.setupEventListeners();
                this.buildNeuralNetworks();
                setTimeout(() => this.requestMicrophone(), 500);
            }

            setupEventListeners() {
                document.getElementById('startBtn').onclick = () => this.toggleRecording();
                document.getElementById('stopAudioBtn').onclick = () => this.stopAllAudio();
                document.querySelectorAll('.sound-btn').forEach(btn => {
                    btn.onclick = () => this.generateSound(btn.dataset.sound);
                    btn.ontouchstart = () => this.generateSound(btn.dataset.sound);
                });
            }

            buildNeuralNetworks() {
                try {
                    this.nn.cnn = new SimpleCNN(32, 32);
                    this.nn.rnn = new SimpleRNN(64, 16);
                    this.nn.transformer = new SimpleTransformer(64, 4, 16);
                    document.getElementById('status').textContent = 'Ready! Click Start Analysis to begin.';
                } catch (error) {
                    document.getElementById('status').textContent = '‚ùå Critical error building neural networks.';
                }
            }

            async requestMicrophone() {
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                    stream.getTracks().forEach(track => track.stop());
                    document.getElementById('status').textContent = 'Ready! Click Start Analysis to begin.';
                } catch (error) {
                    document.getElementById('status').textContent = 'üé§ Mic denied. Sound generation still available.';
                }
            }

            async toggleRecording() {
                this.isRecording ? this.stopRecording() : await this.startRecording();
            }

            async startRecording() {
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    if (this.audioContext.state === 'suspended') {
                        await this.audioContext.resume();
                    }
                    const source = this.audioContext.createMediaStreamSource(stream);
                    this.analyser = this.audioContext.createAnalyser();
                    this.analyser.fftSize = 512;
                    source.connect(this.analyser);
                    this.audioBuffer = new Uint8Array(this.analyser.frequencyBinCount);
                    this.isRecording = true;
                    document.getElementById('startBtn').textContent = 'Stop Analysis';
                    document.getElementById('startBtn').classList.add('active');
                    document.getElementById('status').textContent = 'Listening and classifying...';
                    this.startClassificationLoop();
                } catch (error) {
                    document.getElementById('status').textContent = '‚ùå Mic access required to start analysis.';
                }
            }

            stopRecording() {
                if (this.audioContext) {
                    this.audioContext.close().catch(() => {});
                }
                this.isRecording = false;
                this.audioBuffer = null;
                document.getElementById('startBtn').textContent = 'Start Analysis';
                document.getElementById('startBtn').classList.remove('active');
                document.getElementById('status').textContent = 'Ready! Click Start Analysis to begin.';
            }

            startClassificationLoop() {
                const classify = () => {
                    if (!this.isRecording || !this.audioBuffer) return;
                    this.analyser.getByteFrequencyData(this.audioBuffer);
                    this.runNeuralNetworks();
                    this.updateRecommendations();
                    this.displayResults();
                    requestAnimationFrame(classify);
                };
                classify();
            }

            runNeuralNetworks() {
                if (!this.audioBuffer) return;
                const spectrum = this.createSpectrumInput();
                const sequence = this.createSequenceInput();
                const cnnOut = this.nn.cnn.predict(spectrum);
                const rnnOut = this.nn.rnn.predict(sequence);
                const transformerOut = this.nn.transformer.predict(sequence);
                for (let i = 0; i < 4; i++) {
                    this.predictions[i] = (cnnOut[i] * 0.4 + rnnOut[i] * 0.3 + transformerOut[i] * 0.3);
                }
                this.predictions = this.softmax(this.predictions);
            }

            updateRecommendations() {
                const recs = [
                    ['white', 'ocean', 'forest'],
                    ['white', 'cafe', 'rain'],
                    ['rain', 'ocean', 'forest'],
                    ['forest', 'rain', 'cafe']
                ];
                const dominant = this.predictions.indexOf(Math.max(...this.predictions));
                this.recommendations = recs[dominant];
                document.querySelectorAll('.sound-btn').forEach(btn => {
                    btn.classList.remove('recommended');
                    if (this.recommendations.includes(btn.dataset.sound)) {
                        btn.classList.add('recommended');
                    }
                });
            }

            displayResults() {
                const labels = ['Traffic', 'Conversation', 'Construction', 'Quiet'];
                const dominant = this.predictions.indexOf(Math.max(...this.predictions));
                const confidence = Math.round(this.predictions[dominant] * 100);
                document.getElementById('result').textContent = `Detected: ${labels[dominant]} (${confidence}%)`;
                document.getElementById('recommend').textContent = `Recommended: ${this.recommendations.map(r => this.capitalize(r)).join(', ')}`;
            }

            generateSound(type) {
                this.stopAllAudio();
                const audioId = type === 'white' ? 'whitenoise' : type;
                const audio = document.getElementById(`audio-${audioId}`);
                const soundButton = document.querySelector(`[data-sound=\"${type}\"]`);
                if (audio) {
                    const playPromise = audio.play();
                    if (playPromise !== undefined) {
                        playPromise.catch(() => {});
                    }
                    soundButton.classList.add('playing');
                    const durationInput = document.getElementById('timerInput');
                    const duration = parseFloat(durationInput.value);
                    if (!isNaN(duration) && duration > 0) {
                        this.activeTimer = setTimeout(() => {
                            audio.pause();
                            audio.currentTime = 0;
                            soundButton.classList.remove('playing');
                            this.activeTimer = null;
                        }, duration * 1000);
                    }
                }
            }

            stopAllAudio() {
                if (this.activeTimer) {
                    clearTimeout(this.activeTimer);
                    this.activeTimer = null;
                }
                document.querySelectorAll('audio').forEach(audio => {
                    audio.pause();
                    audio.currentTime = 0;
                });
                document.querySelectorAll('.sound-btn').forEach(btn => {
                    btn.classList.remove('playing');
                });
            }

            createSpectrumInput() {
                const spectrum = [];
                for (let i = 0; i < 32; i++) {
                    const row = [];
                    for (let j = 0; j < 32; j++) {
                        const idx = Math.floor((i * 32 + j) / (32 * 32) * this.audioBuffer.length);
                        row.push((this.audioBuffer[idx] || 0) / 255);
                    }
                    spectrum.push(row);
                }
                return spectrum;
            }

            createSequenceInput() {
                const seq = [];
                for (let i = 0; i < 64; i++) {
                    const idx = Math.floor((i / 64) * this.audioBuffer.length);
                    seq.push((this.audioBuffer[idx] || 0) / 255);
                }
                return seq;
            }

            softmax(arr) {
                const max = Math.max(...arr);
                const exp = arr.map(x => Math.exp(x - max));
                const sum = exp.reduce((a, b) => a + b, 0);
                return exp.map(x => x / sum);
            }

            capitalize(str) {
                return str.charAt(0).toUpperCase() + str.slice(1);
            }
        }

        // --- Simple neural network stubs (unchanged) ---
        class SimpleCNN {
            constructor(inputW, inputH) {
                this.kernel = [-1, 2, -1];
                this.inputW = inputW;
                this.inputH = inputH;
            }
            predict(spectrogram) {
                let convolved = [];
                for (let r = 0; r < this.inputH; r++) {
                    let row = [];
                    for (let c = 1; c < this.inputW - 1; c++) {
                        let sum = spectrogram[r][c-1] * this.kernel[0] + spectrogram[r][c] * this.kernel[1] + spectrogram[r][c+1] * this.kernel[2];
                        row.push(Math.tanh(sum));
                    }
                    convolved.push(row);
                }
                let pooled = [];
                for (let r = 0; r < convolved.length; r++) {
                    for (let c = 0; c < convolved[r].length - 1; c += 2) {
                        pooled.push(Math.max(convolved[r][c], convolved[r][c+1]));
                    }
                }
                const sum = pooled.reduce((a, b) => a + Math.abs(b), 0);
                const avg = sum / (pooled.length || 1);
                return [avg * 1.5, avg * 0.8, avg * 0.5, avg * 1.1];
            }
        }

        class SimpleRNN {
            constructor(inputSize, hiddenSize) {
                this.hiddenSize = hiddenSize;
                this.wh = Array.from({ length: hiddenSize }, () => Math.random() - 0.5);
                this.hh = Array.from({ length: hiddenSize }, () => Math.random() - 0.5);
                this.hidden = Array.from({ length: hiddenSize }, () => 0);
            }
            predict(sequence) {
                this.hidden.fill(0);
                for (const input of sequence) {
                    const newHidden = Array(this.hiddenSize).fill(0);
                    for (let i = 0; i < this.hiddenSize; i++) {
                        newHidden[i] = Math.tanh(input * this.wh[i] + this.hidden[i] * this.hh[i]);
                    }
                    this.hidden = newHidden;
                }
                const sum = this.hidden.reduce((a, b) => a + b, 0);
                return [ Math.abs(sum * 0.1), Math.abs(sum * 0.15), Math.abs(sum * 0.05), Math.abs(sum * 0.12) ];
            }
        }

        class SimpleTransformer {
            constructor(inputDim, numHeads, headSize) {
                this.inputDim = inputDim;
                this.numHeads = numHeads;
                this.headSize = headSize;
                this.Wq = Array.from({length: numHeads}, () => Array.from({length: headSize}, () => Math.random() - 0.5));
                this.Wk = Array.from({length: numHeads}, () => Array.from({length: headSize}, () => Math.random() - 0.5));
                this.Wv = Array.from({length: numHeads}, () => Array.from({length: headSize}, () => Math.random() - 0.5));
            }
            predict(sequence) {
                let embedded = sequence.map((val, i) => val + Math.sin(i / 10));
                let attendedOutputs = [];
                for(let h = 0; h < this.numHeads; h++) {
                    let q = embedded.map(val => val * this.Wq[h][0]);
                    let k = embedded.map(val => val * this.Wk[h][0]);
                    let v = embedded.map(val => val * this.Wv[h][0]);
                    let attentionScores = q.map((qi, i) => k.map((kj, j) => qi * kj));
                    let attentionWeights = attentionScores.map(row => this.softmax(row));
                    let headOutput = attentionWeights.map((weights, i) => {
                        return v.reduce((sum, vj, j) => sum + vj * weights[j], 0);
                    });
                    attendedOutputs.push(...headOutput);
                }
                const sum = attendedOutputs.reduce((a, b) => a + Math.abs(b), 0);
                const avg = sum / (attendedOutputs.length || 1);
                return [avg * 1.1, avg * 1.3, avg * 0.9, avg * 0.7];
            }
            softmax(arr) {
                if (!arr || arr.length === 0) return [];
                const max = Math.max(...arr);
                const exp = arr.map(x => Math.exp(x - max));
                const sum = exp.reduce((a, b) => a + b, 0);
                return exp.map(x => x / (sum || 1));
            }
        }

        window.onload = () => new SoundMaskAI();
    </script>
</body>
</html>